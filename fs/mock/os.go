// /*
// Copyright 2025 Flant JSC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// */

// Code generated by MockGen. DO NOT EDIT.
// Source: os.go
//
// Generated by this command:
//
//	mockgen -typed -package mock -copyright_file ../hack/boilerplate.txt -write_source_comment -destination=mock/os.go -source=os.go
//

// Package mock is a generated GoMock package.
package mock

import (
	fs0 "io/fs"
	os "os"
	reflect "reflect"

	fs "github.com/deckhouse/sds-common-lib/fs"
	gomock "go.uber.org/mock/gomock"
)

// MockOS is a mock of OS interface.
type MockOS struct {
	ctrl     *gomock.Controller
	recorder *MockOSMockRecorder
	isgomock struct{}
}

// MockOSMockRecorder is the mock recorder for MockOS.
type MockOSMockRecorder struct {
	mock *MockOS
}

// NewMockOS creates a new mock instance.
func NewMockOS(ctrl *gomock.Controller) *MockOS {
	mock := &MockOS{ctrl: ctrl}
	mock.recorder = &MockOSMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOS) EXPECT() *MockOSMockRecorder {
	return m.recorder
}

// Chdir mocks base method.
func (m *MockOS) Chdir(dir string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chdir", dir)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chdir indicates an expected call of Chdir.
func (mr *MockOSMockRecorder) Chdir(dir any) *MockOSChdirCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chdir", reflect.TypeOf((*MockOS)(nil).Chdir), dir)
	return &MockOSChdirCall{Call: call}
}

// MockOSChdirCall wrap *gomock.Call
type MockOSChdirCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSChdirCall) Return(arg0 error) *MockOSChdirCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSChdirCall) Do(f func(string) error) *MockOSChdirCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSChdirCall) DoAndReturn(f func(string) error) *MockOSChdirCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Chmod mocks base method.
func (m *MockOS) Chmod(name string, mode fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chmod", name, mode)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chmod indicates an expected call of Chmod.
func (mr *MockOSMockRecorder) Chmod(name, mode any) *MockOSChmodCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chmod", reflect.TypeOf((*MockOS)(nil).Chmod), name, mode)
	return &MockOSChmodCall{Call: call}
}

// MockOSChmodCall wrap *gomock.Call
type MockOSChmodCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSChmodCall) Return(arg0 error) *MockOSChmodCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSChmodCall) Do(f func(string, fs.FileMode) error) *MockOSChmodCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSChmodCall) DoAndReturn(f func(string, fs.FileMode) error) *MockOSChmodCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Chown mocks base method.
func (m *MockOS) Chown(name string, uid, gid int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chown", name, uid, gid)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chown indicates an expected call of Chown.
func (mr *MockOSMockRecorder) Chown(name, uid, gid any) *MockOSChownCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chown", reflect.TypeOf((*MockOS)(nil).Chown), name, uid, gid)
	return &MockOSChownCall{Call: call}
}

// MockOSChownCall wrap *gomock.Call
type MockOSChownCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSChownCall) Return(arg0 error) *MockOSChownCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSChownCall) Do(f func(string, int, int) error) *MockOSChownCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSChownCall) DoAndReturn(f func(string, int, int) error) *MockOSChownCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Create mocks base method.
func (m *MockOS) Create(name string) (fs.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", name)
	ret0, _ := ret[0].(fs.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create.
func (mr *MockOSMockRecorder) Create(name any) *MockOSCreateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockOS)(nil).Create), name)
	return &MockOSCreateCall{Call: call}
}

// MockOSCreateCall wrap *gomock.Call
type MockOSCreateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSCreateCall) Return(arg0 fs.File, arg1 error) *MockOSCreateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSCreateCall) Do(f func(string) (fs.File, error)) *MockOSCreateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSCreateCall) DoAndReturn(f func(string) (fs.File, error)) *MockOSCreateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DirFS mocks base method.
func (m *MockOS) DirFS(dir string) fs0.FS {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DirFS", dir)
	ret0, _ := ret[0].(fs0.FS)
	return ret0
}

// DirFS indicates an expected call of DirFS.
func (mr *MockOSMockRecorder) DirFS(dir any) *MockOSDirFSCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DirFS", reflect.TypeOf((*MockOS)(nil).DirFS), dir)
	return &MockOSDirFSCall{Call: call}
}

// MockOSDirFSCall wrap *gomock.Call
type MockOSDirFSCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSDirFSCall) Return(arg0 fs0.FS) *MockOSDirFSCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSDirFSCall) Do(f func(string) fs0.FS) *MockOSDirFSCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSDirFSCall) DoAndReturn(f func(string) fs0.FS) *MockOSDirFSCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Getwd mocks base method.
func (m *MockOS) Getwd() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Getwd")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Getwd indicates an expected call of Getwd.
func (mr *MockOSMockRecorder) Getwd() *MockOSGetwdCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Getwd", reflect.TypeOf((*MockOS)(nil).Getwd))
	return &MockOSGetwdCall{Call: call}
}

// MockOSGetwdCall wrap *gomock.Call
type MockOSGetwdCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSGetwdCall) Return(dir string, err error) *MockOSGetwdCall {
	c.Call = c.Call.Return(dir, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSGetwdCall) Do(f func() (string, error)) *MockOSGetwdCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSGetwdCall) DoAndReturn(f func() (string, error)) *MockOSGetwdCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Lstat mocks base method.
func (m *MockOS) Lstat(name string) (fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lstat", name)
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lstat indicates an expected call of Lstat.
func (mr *MockOSMockRecorder) Lstat(name any) *MockOSLstatCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lstat", reflect.TypeOf((*MockOS)(nil).Lstat), name)
	return &MockOSLstatCall{Call: call}
}

// MockOSLstatCall wrap *gomock.Call
type MockOSLstatCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSLstatCall) Return(arg0 fs.FileInfo, arg1 error) *MockOSLstatCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSLstatCall) Do(f func(string) (fs.FileInfo, error)) *MockOSLstatCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSLstatCall) DoAndReturn(f func(string) (fs.FileInfo, error)) *MockOSLstatCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mkdir mocks base method.
func (m *MockOS) Mkdir(name string, perm os.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Mkdir", name, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// Mkdir indicates an expected call of Mkdir.
func (mr *MockOSMockRecorder) Mkdir(name, perm any) *MockOSMkdirCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Mkdir", reflect.TypeOf((*MockOS)(nil).Mkdir), name, perm)
	return &MockOSMkdirCall{Call: call}
}

// MockOSMkdirCall wrap *gomock.Call
type MockOSMkdirCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSMkdirCall) Return(arg0 error) *MockOSMkdirCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSMkdirCall) Do(f func(string, os.FileMode) error) *MockOSMkdirCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSMkdirCall) DoAndReturn(f func(string, os.FileMode) error) *MockOSMkdirCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MkdirAll mocks base method.
func (m *MockOS) MkdirAll(path string, perm os.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkdirAll", path, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkdirAll indicates an expected call of MkdirAll.
func (mr *MockOSMockRecorder) MkdirAll(path, perm any) *MockOSMkdirAllCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkdirAll", reflect.TypeOf((*MockOS)(nil).MkdirAll), path, perm)
	return &MockOSMkdirAllCall{Call: call}
}

// MockOSMkdirAllCall wrap *gomock.Call
type MockOSMkdirAllCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSMkdirAllCall) Return(arg0 error) *MockOSMkdirAllCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSMkdirAllCall) Do(f func(string, os.FileMode) error) *MockOSMkdirAllCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSMkdirAllCall) DoAndReturn(f func(string, os.FileMode) error) *MockOSMkdirAllCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Open mocks base method.
func (m *MockOS) Open(name string) (fs.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Open", name)
	ret0, _ := ret[0].(fs.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Open indicates an expected call of Open.
func (mr *MockOSMockRecorder) Open(name any) *MockOSOpenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*MockOS)(nil).Open), name)
	return &MockOSOpenCall{Call: call}
}

// MockOSOpenCall wrap *gomock.Call
type MockOSOpenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSOpenCall) Return(arg0 fs.File, arg1 error) *MockOSOpenCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSOpenCall) Do(f func(string) (fs.File, error)) *MockOSOpenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSOpenCall) DoAndReturn(f func(string) (fs.File, error)) *MockOSOpenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OpenFile mocks base method.
func (m *MockOS) OpenFile(name string, flag int, perm fs.FileMode) (fs.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenFile", name, flag, perm)
	ret0, _ := ret[0].(fs.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenFile indicates an expected call of OpenFile.
func (mr *MockOSMockRecorder) OpenFile(name, flag, perm any) *MockOSOpenFileCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenFile", reflect.TypeOf((*MockOS)(nil).OpenFile), name, flag, perm)
	return &MockOSOpenFileCall{Call: call}
}

// MockOSOpenFileCall wrap *gomock.Call
type MockOSOpenFileCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSOpenFileCall) Return(arg0 fs.File, arg1 error) *MockOSOpenFileCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSOpenFileCall) Do(f func(string, int, fs.FileMode) (fs.File, error)) *MockOSOpenFileCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSOpenFileCall) DoAndReturn(f func(string, int, fs.FileMode) (fs.File, error)) *MockOSOpenFileCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadDir mocks base method.
func (m *MockOS) ReadDir(name string) ([]fs.DirEntry, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadDir", name)
	ret0, _ := ret[0].([]fs.DirEntry)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadDir indicates an expected call of ReadDir.
func (mr *MockOSMockRecorder) ReadDir(name any) *MockOSReadDirCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadDir", reflect.TypeOf((*MockOS)(nil).ReadDir), name)
	return &MockOSReadDirCall{Call: call}
}

// MockOSReadDirCall wrap *gomock.Call
type MockOSReadDirCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSReadDirCall) Return(arg0 []fs.DirEntry, arg1 error) *MockOSReadDirCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSReadDirCall) Do(f func(string) ([]fs.DirEntry, error)) *MockOSReadDirCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSReadDirCall) DoAndReturn(f func(string) ([]fs.DirEntry, error)) *MockOSReadDirCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadLink mocks base method.
func (m *MockOS) ReadLink(name string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadLink", name)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadLink indicates an expected call of ReadLink.
func (mr *MockOSMockRecorder) ReadLink(name any) *MockOSReadLinkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadLink", reflect.TypeOf((*MockOS)(nil).ReadLink), name)
	return &MockOSReadLinkCall{Call: call}
}

// MockOSReadLinkCall wrap *gomock.Call
type MockOSReadLinkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSReadLinkCall) Return(arg0 string, arg1 error) *MockOSReadLinkCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSReadLinkCall) Do(f func(string) (string, error)) *MockOSReadLinkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSReadLinkCall) DoAndReturn(f func(string) (string, error)) *MockOSReadLinkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Stat mocks base method.
func (m *MockOS) Stat(name string) (fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stat", name)
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stat indicates an expected call of Stat.
func (mr *MockOSMockRecorder) Stat(name any) *MockOSStatCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stat", reflect.TypeOf((*MockOS)(nil).Stat), name)
	return &MockOSStatCall{Call: call}
}

// MockOSStatCall wrap *gomock.Call
type MockOSStatCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSStatCall) Return(arg0 fs.FileInfo, arg1 error) *MockOSStatCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSStatCall) Do(f func(string) (fs.FileInfo, error)) *MockOSStatCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSStatCall) DoAndReturn(f func(string) (fs.FileInfo, error)) *MockOSStatCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Symlink mocks base method.
func (m *MockOS) Symlink(oldName, newName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Symlink", oldName, newName)
	ret0, _ := ret[0].(error)
	return ret0
}

// Symlink indicates an expected call of Symlink.
func (mr *MockOSMockRecorder) Symlink(oldName, newName any) *MockOSSymlinkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Symlink", reflect.TypeOf((*MockOS)(nil).Symlink), oldName, newName)
	return &MockOSSymlinkCall{Call: call}
}

// MockOSSymlinkCall wrap *gomock.Call
type MockOSSymlinkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOSSymlinkCall) Return(arg0 error) *MockOSSymlinkCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOSSymlinkCall) Do(f func(string, string) error) *MockOSSymlinkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOSSymlinkCall) DoAndReturn(f func(string, string) error) *MockOSSymlinkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
